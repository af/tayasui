/**
Here's an element you already know and love: the humble button.

https://css-tricks.com/explaining-the-accessible-benefits-of-using-semantic-html-elements/

```html
<button>Default</button>
<button data-variant="outline">Outline</button>
<button data-variant="outline" data-action="danger">Danger</button>
<a href="#fake" data-as="button">Link Button</a>
<button data-variant="text">Text button</button>
```

Loading and disabled states, using standard attributes:
```html
<hstack-i>
<button disabled aria-busy="true">Loading</button>
<button disabled>Disabled</button>
</hstack-i>
```

Small buttons:
```html
<hstack-i gap="s" vpad="s">
  <button data-size="s">Smol</button>
  <button data-size="s" data-variant="outline">Smol2</button>
  <button data-size="s" data-variant="outline" disabled aria-busy="true">Smol</button>
  <button data-size="s" data-variant="outline" data-action="danger">smol danger</button>
</hstack-i>
```

## ButtonGroup
```html
<buttongroup-i>
  <button>group 1</button>
  <button>group 2</button>
</buttongroup-i>
```

```html
<buttongroup-i>
  <button data-variant="outline">group 1</button>
  <button data-variant="outline">group 2</button>
  <button data-variant="outline">group 3</button>
</buttongroup-i>
```

Buttongroup can also be used to wrap radio buttons:
```html
<buttongroup-i>
  <label>
    Option 1 <input type="radio" name="radio-group" checked>
  </label>
  <label>
    Option 2 <input type="radio" name="radio-group">
  </label>
  <label>
    Option 3 <input type="radio" name="radio-group">
  </label>
</buttongroup-i>
```
**/
@layer tayasui.base {
  @keyframes spin {
    from {
      transform: rotate(0deg);
    }

    to {
      transform: rotate(360deg);
    }
  }

  /* todo: add data-* attributes to tayasui.d.ts? */
  /* todo: better name than data-action */
  button,
  [data-as="button"] {
    --color: var(--color-bg-cta);
    --radius: var(--border-radius-s);
    --borderWidth: 1px;

    display: inline-flex;
    gap: var(--spacing-xs);
    align-items: center;
    justify-content: center;
    background-color: var(--color);
    color: var(--color-fg-cta);
    font-family: inherit;
    line-height: 1.7;
    padding: var(--spacing-xxs) var(--spacing-m);
    border: var(--borderWidth) solid var(--color);
    /* ensure equivalent height to outline buttons */
    border-radius: var(--radius);
    text-decoration: none;
    position: relative;

    &:hover {
      --color: var(--color-bg-cta-hover, var(--color-bg-cta));
      /* ensure a[data-as="button"] hover color works */
      color: var(--color-fg-cta);
    }

    &:active:not(:disabled) {
      transform: scale(0.98);
    }

    &[data-variant="outline"] {
      color: var(--color);
      background-color: transparent;

      &[aria-busy="true"]::before {
        color: var(--color);
      }
    }

    &[data-variant="text"] {
      --color: var(--color-fg-link);
      color: var(--color);
      background-color: transparent;
      border: none;
      padding: 0;
    }

    &[data-action="danger"] {
      --color: var(--color-fg-danger);
    }

    &[data-size="s"] {
      font-size: var(--font-size-s);
      padding: 0 var(--spacing-s);
    }

    &:disabled,
    &:disabled:hover {
      /* don't have hover state override this */
      --color: var(--color-bg-cta);
    }

    &[aria-busy="true"] {
      /* hide text so only spinner is visible */
      color: transparent;
    }

    &[aria-busy="true"]::before {
      /* TODO: center this in the button when it's visible */
      /* tricky because we're already using transform for the animation */
      content: "";
      width: 1em;
      height: 1em;
      color: var(--color-fg-cta);
      border: 2px solid currentColor;
      border-radius: 50%;
      border-top-color: transparent;
      animation: spin 1s linear infinite;

      /* this appears to successfully center the spinner in the button */
      position: absolute;
      left: 0;
      right: 0;
      margin: auto;
    }

    /* prevent icons from getting squished */
    /* TODO: fix alignment bug when icon is taller than text */
    svg {
      flex-shrink: 0;
    }
  }

  buttongroup-i {
    display: flex;
    gap: 1px;

    button {
      /* only use button radius values defined below for first/last children */
      border-radius: 0;
    }

    >*:first-child {
      border-top-left-radius: var(--radius);
      border-bottom-left-radius: var(--radius);
    }

    >*:last-child {
      border-top-right-radius: var(--radius);
      border-bottom-right-radius: var(--radius);
    }

    button[data-variant="outline"]:not(:first-child),
    label:not(:first-child) {
      margin-left: calc(-1px - var(--borderWidth, 1px));
    }

    /* <buttongroup-i> can also be used to wrap <label>text <input type="radio"></label> items */
    label {
      --radius: var(--border-radius-m);
      border: 1px solid var(--color-border);
      cursor: pointer;
      padding: var(--spacing-xs) var(--spacing-m);

      &:has(input[type="radio"]:checked) {
        color: var(--color-fg-cta);
        background-color: var(--color-bg-cta);
      }
    }

    input[type="radio"] {
      display: none;
    }
  }
}
